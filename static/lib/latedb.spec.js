// Generated by CoffeeScript 1.9.2
(function() {
  var lateDB;

  lateDB = require('chocolate/general/latedb');

  describe('lateDB', function() {
    var db, times;
    db = void 0;
    times = [];
    it('does not already exist ', function() {
      var exists, ready;
      ready = false;
      exists = void 0;
      lateDB.exists(function(e) {
        ready = true;
        return exists = e;
      });
      waitsFor((function() {
        return ready;
      }), 'LateDB to tell if it already exists', 1000);
      return runs(function() {
        return expect(exists).toBe(false);
      });
    });
    it('should create a default DB', function() {
      var ready;
      ready = false;
      db = lateDB();
      db.ready(function() {
        return ready = true;
      });
      expect(db).not.toBe(void 0);
      expect(db.filename()).toBe('db.log');
      waitsFor((function() {
        return ready;
      }), 'LateDB to be ready', 1000);
      return runs(function() {
        return expect(ready).toBe(true);
      });
    });
    it('should log some modifications', function() {
      var ref, ref1, ref2;
      db.update({
        'result': {
          data: 'done',
          op: function(data) {
            return (this.debug_log != null ? this.debug_log : this.debug_log = []).push(data);
          }
        }
      });
      expect((ref = db()) != null ? (ref1 = ref.result.debug_log) != null ? ref1.length : void 0 : void 0).toBe(1);
      return expect((ref2 = db()) != null ? ref2.result.debug_log[0] : void 0).toBe('done');
    });
    it('should flush the modifications to localStorage or to disk', function() {
      var flushed;
      flushed = false;
      runs(function() {
        return db.flushed(function() {
          return flushed = true;
        });
      });
      waitsFor((function() {
        return flushed;
      }), 'LateDB to be flushed', 1000);
      return runs(function() {
        return expect(flushed).toBe(true);
      });
    });
    it('should clear the DB', function() {
      var ref;
      db.clear();
      return expect((ref = db()) != null ? ref.constructor : void 0).toBe({}.constructor);
    });
    it('should reload the DB in the previous state', function() {
      var ready;
      ready = false;
      db = lateDB();
      db.ready(function() {
        return ready = true;
      });
      waitsFor((function() {
        return ready;
      }), 'LateDB to be ready', 1000);
      return runs(function() {
        var ref;
        expect(ready).toBe(true);
        return expect((ref = db()) != null ? ref.result.debug_log[0] : void 0).toBe('done');
      });
    });
    it('should increase the DB size', function() {
      var count, update;
      count = 0;
      update = function() {
        count += 1;
        db.update({
          'result': {
            data: "done " + count + " time" + (count > 1 ? 's' : ''),
            op: function(data) {
              return (this.debug_log != null ? this.debug_log : this.debug_log = []).push(data);
            }
          }
        });
        times.push(Date.now());
        if (count < 5) {
          return setTimeout(update, 200);
        }
      };
      setTimeout(update, 200);
      waitsFor((function() {
        return count === 5;
      }), "database to have its size increased with count", 2000);
      return runs(function() {
        var ref;
        return expect((ref = db()) != null ? ref.result.debug_log[count] : void 0).toBe('done 5 times');
      });
    });
    it('should flush again the modifications to localStorage or to disk', function() {
      var flushed;
      flushed = false;
      runs(function() {
        return db.flushed(function() {
          return flushed = true;
        });
      });
      waitsFor((function() {
        return flushed;
      }), 'LateDB to be flushed again', 1000);
      return runs(function() {
        return expect(flushed).toBe(true);
      });
    });
    it('should revert the DB to some point in the past', function() {
      var done;
      done = false;
      runs(function() {
        return db.revert(times[times.length - 2], function() {
          return done = true;
        });
      });
      waitsFor((function() {
        return done;
      }), 'LateDB to be reverted', 2000);
      return runs(function() {
        var count, ref, ref1;
        count = ((ref = db()) != null ? ref.result.debug_log.length : void 0) - 1;
        return expect((ref1 = db()) != null ? ref1.result.debug_log[count] : void 0).toBe('done 4 times');
      });
    });
    it('should compact at some point in the past', function() {
      var done;
      done = false;
      runs(function() {
        return db.compact(times[times.length - 3], {
          page_size: 10
        }, (function() {
          return done = true;
        }));
      });
      waitsFor((function() {
        return done;
      }), 'LateDB to be compacted in the past', 2000);
      return runs(function() {
        var count, lines, ref, ref1;
        count = ((ref = db()) != null ? ref.result.debug_log.length : void 0) - 1;
        expect((ref1 = db()) != null ? ref1.result.debug_log[count] : void 0).toBe('done 4 times');
        if (typeof window === "undefined" || window === null) {
          lines = require('fs').readFileSync(db.pathname(), 'utf8').split('\n');
          expect(lines[0]).toBe("var _db={'result':{'debug_log':['done','done 1 time','done 2 times','done 3 times']}},_ops=[function (data) {");
          expect(lines[lines.length - 2]).toBe('_(1,0,"done 4 times");');
          return expect(lines[lines.length - 1]).toBe('');
        } else {
          lines = localStorage.getItem('LateDB').split('\n');
          expect(lines[0]).toBe('var _db = {"result":{"debug_log":["done","done 1 time","done 2 times","done 3 times"]}},');
          expect(lines[lines.length - 3]).toBe('_(1,0,"done 4 times");');
          return expect(lines[lines.length - 2]).toBe('');
        }
      });
    });
    it('should compact now', function() {
      var done;
      done = false;
      runs(function() {
        return db.compact({
          page_size: 10
        }, (function() {
          return done = true;
        }));
      });
      waitsFor((function() {
        return done;
      }), 'LateDB to be compacted now', 2000);
      return runs(function() {
        var count, ref, ref1;
        count = ((ref = db()) != null ? ref.result.debug_log.length : void 0) - 1;
        return expect((ref1 = db()) != null ? ref1.result.debug_log[count] : void 0).toBe('done 4 times');
      });
    });
    it('should delete the DB', function() {
      var done;
      done = false;
      runs(function() {
        return db.clear({
          forget: true
        }, function() {
          return done = true;
        });
      });
      waitsFor((function() {
        return done;
      }), 'LateDB to be deleted', 1000);
      return runs(function() {
        var ref;
        return expect((ref = db()) != null ? ref.constructor : void 0).toBe({}.constructor);
      });
    });
    it('should not exist anymore', function() {
      var done, exists;
      done = false;
      exists = void 0;
      lateDB.exists(function(e) {
        done = true;
        return exists = e;
      });
      waitsFor((function() {
        return done;
      }), 'LateDB to tell if it still exists', 1000);
      return runs(function() {
        return expect(exists).toBe(false);
      });
    });
    it('could update a forgot DB by recreating it', function() {
      var flushed;
      db.update({
        'result': {
          data: "done again",
          op: function(data) {
            return (this.debug_log != null ? this.debug_log : this.debug_log = []).push(data);
          }
        }
      });
      flushed = false;
      runs(function() {
        return db.flushed(function() {
          return flushed = true;
        });
      });
      waitsFor((function() {
        return flushed;
      }), 'LateDB to be flushed again', 1000);
      return runs(function() {
        return expect(flushed).toBe(true);
      });
    });
    it('should delete the default DB again', function() {
      var done;
      done = false;
      runs(function() {
        return db.clear({
          forget: true
        }, function() {
          return done = true;
        });
      });
      waitsFor((function() {
        return done;
      }), 'LateDB to be deleted again', 1000);
      return runs(function() {
        var ref;
        return expect((ref = db()) != null ? ref.constructor : void 0).toBe({}.constructor);
      });
    });
    return xit('should not exist anymore again', function() {
      var done, exists;
      done = false;
      exists = void 0;
      lateDB.exists(function(e) {
        done = true;
        return exists = e;
      });
      waitsFor((function() {
        return done;
      }), 'LateDB to tell if it still exists again', 1000);
      return runs(function() {
        return expect(exists).toBe(false);
      });
    });
  });

}).call(this);
