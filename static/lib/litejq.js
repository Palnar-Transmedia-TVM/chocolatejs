// Generated by CoffeeScript 1.12.6
(function() {
  var $, Dom, Events, Query, Style, base, base1, base2, core, core_array, core_hasOwn, core_isArraylike, core_object, core_toArray, core_version, i, k, len1, m, o, previous$, ref, v;

  if (!((typeof window !== "undefined" && window !== null) && !((window.$ != null) && (window.$.fn != null) && (window.$.fn.jquery != null)))) {
    return;
  }

  core_version = "0.1.1";

  core_object = {};

  core_array = [];

  core_toArray = function(a) {
    var i, item, result;
    if ($.type(a) === 'array') {
      return a;
    }
    i = -1;
    result = [];
    while (item = a[++i]) {
      result[i] = item;
    }
    return result;
  };

  core_hasOwn = core_object.hasOwnProperty;

  core_isArraylike = function(obj) {
    var length, type;
    length = obj.length;
    type = $.type(obj);
    if ($.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return type === "array" || type !== "function" && (length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj);
  };

  previous$ = window.$;

  $ = window.litejQ = function(s) {
    return new $.prototype.init(s);
  };

  if (previous$ == null) {
    window.$ = $;
  }

  $.expando = "litejQ" + (core_version + Math.random()).replace(/\D/g, "");

  $.noConflict = function() {
    window.$ = previous$;
    return $;
  };

  $.type = function(obj) {
    var class2type;
    if (obj == null) {
      return String(obj);
    }
    class2type = {
      "[object Boolean]": "boolean",
      "[object Number]": "number",
      "[object String]": "string",
      "[object Function]": "function",
      "[object Array]": "array",
      "[object Date]": "date",
      "[object RegExp]": "regexp",
      "[object Object]": "object",
      "[object Error]": "error"
    };
    if (typeof obj === "object" || typeof obj === "function") {
      return class2type[Object.prototype.toString.call(obj)] || "object";
    } else {
      return typeof obj;
    }
  };

  $.isArray = Array.isArray || function(obj) {
    return $.type(obj) === "array";
  };

  $.isWindow = function(obj) {
    return (obj != null) && obj === obj.window;
  };

  $.isPlainObject = function(obj) {
    var key;
    if (!obj || $.type(obj) !== "object" || obj.nodeType || $.isWindow(obj)) {
      return false;
    }
    try {
      if (obj.constructor && !core_hasOwn.call(obj, "constructor") && !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }
    } catch (error1) {
      return false;
    }
    if ($.support.ownLast) {
      for (key in obj) {
        return core_hasOwn.call(obj, key);
      }
    }
    for (key in obj) {
      ({});
    }
    return key === void 0 || core_hasOwn.call(obj, key);
  };

  $.each = function(elements, callback) {
    var i, key;
    if (core_isArraylike(elements)) {
      i = 0;
      while (i < elements.length) {
        if (callback.call(elements[i], i, elements[i]) === false) {
          return elements;
        }
        i++;
      }
    } else {
      for (key in elements) {
        if (callback.call(elements[key], key, elements[key]) === false) {
          return elements;
        }
      }
    }
    return elements;
  };

  $.map = function(elems, callback, arg) {
    var _mapone, i, length, ret, value;
    ret = [];
    i = 0;
    value = null;
    length = elems.length;
    _mapone = function() {
      value = callback(elems[i], i, arg);
      if (value != null) {
        return ret[ret.length] = value;
      }
    };
    if (core_isArraylike(elems)) {
      while (i < length) {
        _mapone();
        i++;
      }
    } else {
      for (i in elems) {
        _mapone();
      }
    }
    return [].concat.apply([], ret);
  };

  $.extend = function() {
    var clone, copy, copyIsArray, deep, i, length, name, options, src, target;
    target = arguments[0] || {};
    i = 1;
    length = arguments.length;
    deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (typeof target !== "object" && !$.type(target) === "function") {
      target = {};
    }
    if (length === i) {
      target = this;
      --i;
    }
    while (i < length) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && ($.isPlainObject(copy) || (copyIsArray = $.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && $.isArray(src) ? src : [];
            } else {
              clone = src && $.isPlainObject(src) ? src : {};
            }
            target[name] = $.extend(deep, clone, copy);
          } else if (copy !== void 0) {
            target[name] = copy;
          }
        }
      }
      i += 1;
    }
    return target;
  };

  $.globalEval = function(text) {
    var script;
    if (!text) {
      return text;
    }
    if (window.execScript) {
      window.execScript(text);
    } else {
      script = document.createElement('script');
      script.setAttribute('type', 'text/javascript');
      script.text = text;
      document.head.appendChild(script);
      document.head.removeChild(script);
    }
    return text;
  };

  $.Environment = (function() {
    var Mobile_is_webkit, Mobile_supported_os, _current, _detectBrowser, _detectEnvironment, _detectOS, _detectScreen;
    _current = null;
    Mobile_is_webkit = /WebKit\/([\d.]+)/;
    Mobile_supported_os = {
      Android: /(Android)\s+([\d.]+)/,
      ipad: /(iPad).*OS\s([\d_]+)/,
      iphone: /(iPhone\sOS)\s([\d_]+)/,
      Blackberry: /(BlackBerry|BB10|Playbook).*Version\/([\d.]+)/,
      FirefoxOS: /(Mozilla).*Mobile[^\/]*\/([\d\.]*)/,
      webOS: /(webOS|hpwOS)[\s\/]([\d.]+)/
    };
    _detectEnvironment = function() {
      var environment, user_agent;
      user_agent = navigator.userAgent;
      environment = {};
      environment.browser = _detectBrowser(user_agent);
      environment.os = _detectOS(user_agent);
      environment.isMobile = !!environment.os;
      environment.screen = _detectScreen();
      return environment;
    };
    _detectBrowser = function(user_agent) {
      var is_webkit;
      is_webkit = user_agent.match(Mobile_is_webkit);
      if (is_webkit) {
        return is_webkit[0];
      } else {
        return user_agent;
      }
    };
    _detectOS = function(user_agent) {
      var detected_os, os, supported;
      detected_os = null;
      for (os in Mobile_supported_os) {
        supported = user_agent.match(Mobile_supported_os[os]);
        if (supported) {
          detected_os = {
            name: ((os === "iphone" || os === "ipad") ? "ios" : os),
            version: supported[2].replace("_", ".")
          };
          break;
        }
      }
      return detected_os;
    };
    _detectScreen = function() {
      return {
        width: window.innerWidth,
        height: window.innerHeight
      };
    };
    return {
      isMobile: function() {
        _current = _current || _detectEnvironment();
        return _current.isMobile;
      },
      environment: function() {
        _current = _current || _detectEnvironment();
        return _current;
      },
      isOnline: function() {
        return navigator.onLine;
      }
    };
  })();

  $.websocket = function(url, options) {
    var FallbackSocket;
    if (options == null) {
      options = {};
    }
    FallbackSocket = function(url, options) {
      var CLOSED, CLOSING, CONNECTING, OPEN, furl, fws, getFallbackParams, openTimout, poll, pollInterval;
      if (options == null) {
        options = {};
      }
      CONNECTING = 0;
      OPEN = 1;
      CLOSING = 2;
      CLOSED = 3;
      pollInterval = null;
      openTimout = null;
      if (options.fallbackPollInterval == null) {
        options.fallbackPollInterval = 3000;
      }
      if (options.fallbackPollParams == null) {
        options.fallbackPollParams = {};
      }
      if (options.fallbackOnly == null) {
        options.fallbackOnly = false;
      }
      furl = url.replace('ws:', 'http:').replace('wss:', 'https:');
      fws = {
        readyState: CONNECTING,
        bufferedAmount: 0,
        send: function(data) {
          var success;
          if (fws.socket_id == null) {
            return false;
          }
          success = true;
          $.ajax({
            type: 'POST',
            url: furl + '?' + $.param(getFallbackParams()),
            data: data,
            dataType: 'text',
            headers: {
              'x-litejq-websocket': 'fallback',
              'x-litejq-websocket-id': fws.socket_id
            },
            contentType: "application/x-www-form-urlencoded; charset=utf-8",
            success: function(data) {
              return fws.onmessage({
                "data": data
              });
            },
            error: function(xhr) {
              success = false;
              return fws.onerror(xhr);
            }
          });
          return success;
        },
        close: function() {
          clearTimeout(openTimout);
          clearInterval(pollInterval);
          this.readyState = CLOSED;
          return fws.onclose();
        },
        onopen: function() {},
        onmessage: function() {},
        onerror: function() {},
        onclose: function() {},
        previousRequest: null,
        currentRequest: null,
        socket_id: null
      };
      getFallbackParams = function() {
        fws.previousRequest = fws.currentRequest;
        fws.currentRequest = new Date().getTime();
        return $.extend({
          "previousRequest": fws.previousRequest,
          "currentRequest": fws.currentRequest
        }, options.fallbackPollParams);
      };
      poll = function() {
        if (fws.socket_id == null) {
          return;
        }
        return $.ajax({
          type: 'GET',
          url: furl + '?' + $.param(getFallbackParams()),
          dataType: 'text',
          headers: {
            'x-litejq-websocket': 'fallback',
            'x-litejq-websocket-id': fws.socket_id
          },
          success: function(data) {
            fws.onmessage({
              "data": data
            });
            if ((data != null) && data !== '') {
              return setTimeout(poll, 0);
            }
          },
          error: function(xhr) {
            return fws.onerror(xhr);
          }
        });
      };
      $.ajax({
        type: 'OPTIONS',
        url: furl,
        dataType: 'text',
        headers: {
          'x-litejq-websocket': 'fallback'
        },
        success: function(data, xhr) {
          fws.socket_id = xhr.getResponseHeader('x-litejq-websocket-id');
          fws.readyState = OPEN;
          fws.onopen();
          poll();
          return pollInterval = setInterval(poll, options.fallbackPollInterval);
        },
        error: function(xhr) {
          return fws.onerror(xhr);
        }
      });
      return fws;
    };
    if (options.fallbackOnly || !window.WebSocket) {
      return new FallbackSocket(url, options);
    } else {
      return new WebSocket(url);
    }
  };

  $.Ajax = (function() {
    var Ajax_default, Ajax_jsonp_id, Ajax_mime_types, Ajax_settings, _jsonp, _parseResponse, _xhrError, _xhrForm, _xhrHeaders, _xhrId, _xhrStatus, _xhrSuccess, _xhrTimeout;
    Ajax_default = {
      type: "GET",
      mime: "guess"
    };
    Ajax_mime_types = {
      script: "text/javascript, application/javascript",
      json: "application/json",
      'json-late': "application/json-late",
      xml: "application/xml, text/xml",
      html: "text/html",
      text: "text/plain",
      guess: "application/xml, text/xml, application/json, application/json-late, text/javascript, application/javascript, text/plain, text/html"
    };
    Ajax_jsonp_id = 0;
    Ajax_settings = {
      type: Ajax_default.type,
      async: true,
      success: function() {},
      error: function() {},
      context: null,
      dataType: Ajax_default.mime,
      headers: {
        'x-requested-with': 'XMLHttpRequest'
      },
      xhr: function() {
        return new window.XMLHttpRequest();
      },
      crossDomain: false,
      timeout: 0,
      cache: true
    };
    $.ajax = function(url, options) {
      var abortTimeout, dataType, error, settings, xhr;
      options = typeof url === "object" ? url : $.extend(options, {
        url: url
      });
      settings = $.extend({}, Ajax_settings, options);
      if (settings.type === Ajax_default.type) {
        if (settings.data != null) {
          settings.url += "?" + $.param(settings.data);
          delete settings.data;
        }
      } else {
        settings.data = $.param(settings.data);
      }
      dataType = settings.dataType.toLowerCase();
      if (settings.cache === false || (options != null ? options.cache : void 0) !== true && (dataType === 'jsonp' || dataType === 'script')) {
        settings.url += (settings.url.indexOf('?') >= 0 ? '&' : '?') + "_=" + (_xhrId++).toString(36);
      }
      if (dataType === 'jsonp') {
        return _jsonp(settings);
      }
      xhr = settings.xhr();
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          clearTimeout(abortTimeout);
          return _xhrStatus(xhr, settings);
        }
      };
      xhr.open(settings.type, settings.url, settings.async);
      _xhrHeaders(xhr, settings);
      if (settings.timeout > 0) {
        abortTimeout = setTimeout((function() {
          return _xhrTimeout(xhr, settings);
        }), settings.timeout);
      }
      try {
        xhr.send(settings.data);
      } catch (error1) {
        error = error1;
        xhr = error;
        _xhrError("Resource not found", xhr, settings);
      }
      if (settings.async) {
        return xhr;
      } else {
        return _parseResponse(xhr, settings);
      }
    };
    $.get = function(url, data, success, dataType) {
      return $.ajax({
        url: url,
        data: data,
        success: success,
        dataType: dataType
      });
    };
    $.post = function(url, data, success, dataType) {
      return _xhrForm("POST", url, data, success, dataType);
    };
    $.getJSON = $.getJson = function(url, data, success) {
      return $.get(url, data, success, 'json');
    };
    $.getScript = function(url, success) {
      return $.get(url, void 0, success, "script");
    };
    $.param = function(parameters) {
      var parameter, serialize;
      if ($.type(parameters) === 'string') {
        return encodeURIComponent(parameters);
      }
      serialize = [];
      for (parameter in parameters) {
        if (parameters.hasOwnProperty(parameter)) {
          serialize.push((encodeURIComponent(parameter)) + "=" + (encodeURIComponent(parameters[parameter])));
        }
      }
      return serialize.join('&');
    };
    _xhrId = Date.now();
    _xhrStatus = function(xhr, settings) {
      if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 0) {
        if (settings.async) {
          _xhrSuccess(_parseResponse(xhr, settings), xhr, settings);
        }
      } else {
        _xhrError("$.ajax: Unsuccesful request", xhr, settings);
      }
    };
    _xhrSuccess = function(response, xhr, settings) {
      settings.success.call(settings.context, response, xhr);
    };
    _xhrError = function(type, xhr, settings) {
      settings.error.call(settings.context, type, xhr, settings);
    };
    _xhrHeaders = function(xhr, settings) {
      var header;
      if (settings.contentType) {
        settings.headers["Content-Type"] = settings.contentType;
      }
      if (settings.dataType) {
        settings.headers["Accept"] = Ajax_mime_types[settings.dataType];
      }
      for (header in settings.headers) {
        xhr.setRequestHeader(header, settings.headers[header]);
      }
    };
    _xhrTimeout = function(xhr, settings) {
      xhr.onreadystatechange = {};
      xhr.abort();
      _xhrError("$.ajax: Timeout exceeded", xhr, settings);
    };
    _xhrForm = function(method, url, data, success, dataType) {
      return $.ajax({
        type: method,
        url: url,
        data: data,
        success: success,
        dataType: dataType,
        contentType: "application/x-www-form-urlencoded"
      });
    };
    _parseResponse = function(xhr, settings) {
      var error, response;
      response = xhr.responseText;
      if (response) {
        switch (settings.dataType) {
          case 'json':
            try {
              response = JSON.parse(response);
            } catch (error1) {
              error = error1;
              response = error;
              _xhrError("$.ajax: Parse Error", xhr, settings);
            }
            break;
          case "xml":
            response = xhr.responseXML;
            break;
          case "script":
            $.globalEval(response);
        }
      }
      return response;
    };
    return _jsonp = function(settings) {
      var abortTimeout, callbackName, script, xhr;
      if (settings.async) {
        callbackName = "jsonp" + (++Ajax_jsonp_id);
        script = document.createElement("script");
        xhr = {
          abort: function() {
            $(script).remove();
            if (callbackName in window) {
              return window[callbackName] = {};
            }
          }
        };
        abortTimeout = void 0;
        window[callbackName] = function(response) {
          clearTimeout(abortTimeout);
          $(script).remove();
          delete window[callbackName];
          return _xhrSuccess(response, xhr, settings);
        };
        script.src = settings.url + (settings.url.indexOf('?') >= 0 ? '&' : '?') + "callback=" + callbackName;
        $("head").append(script);
        if (settings.timeout > 0) {
          abortTimeout = setTimeout((function() {
            return _xhrTimeout(xhr, settings);
          }), settings.timeout);
        }
        return xhr;
      } else {
        return console.error("$.ajax: Unable to make jsonp synchronous call.");
      }
    };
  })();

  Query = (function($) {
    var _filtered, _findAncestors, _findParents, _getSibling, _query;
    _getSibling = function(command) {
      return this.map(function(index, element) {
        element = element[command];
        while (element && element.nodeType !== 1) {
          element = element[command];
        }
        return [element];
      });
    };
    _query = function(domain, selector) {
      var elements;
      selector = selector.trim();
      if (/^\.([\w-]+)$/.test(selector)) {
        elements = domain.getElementsByClassName(selector.replace(".", ""));
      } else if (/^[\w-]+$/.test(selector)) {
        elements = domain.getElementsByTagName(selector);
      } else if (/^#[\w\d-]+$/.test(selector) && domain === document) {
        elements = domain.getElementById(selector.replace("#", ""));
        if (!elements) {
          elements = [];
        }
      } else {
        elements = domain.querySelectorAll(selector);
      }
      if (elements.nodeType) {
        return [elements];
      } else {
        return [].slice.call(core_toArray(elements));
      }
    };
    _findAncestors = function(nodes, depth) {
      var ancestors;
      ancestors = [];
      while (nodes.length > 0) {
        nodes = $.map(nodes, function(node) {
          if (depth !== 0 && (node = node.parentNode) && node !== document && ancestors.indexOf(node) < 0) {
            ancestors.push(node);
            if (depth > 0) {
              depth += -1;
            }
            return node;
          }
        });
      }
      return ancestors;
    };
    _filtered = function(nodes, selector) {
      if (selector === void 0) {
        return $(nodes);
      } else {
        return $(nodes).filter(selector);
      }
    };
    _findParents = function(selector, depth) {
      var instance;
      instance = (function(_this) {
        return function(property) {
          return _this.map(function() {
            return this[property];
          });
        };
      })(this);
      return _filtered((selector != null ? _findAncestors(this, depth) : instance("parentNode")), selector);
    };
    return {
      filter: function(selector) {
        return $([].filter.call(this, function(element) {
          return element.parentNode && _query(element.parentNode, selector).indexOf(element) >= 0;
        }));
      },
      find: function(selector) {
        return $(this.length === 1 ? _query(this[0], selector) : this.map(function() {
          return _query(this, selector);
        }));
      },
      parent: function(selector) {
        return _findParents.call(this, selector, 1);
      },
      parents: function(selector) {
        return _findParents.call(this, selector);
      },
      siblings: function(selector) {
        var siblings;
        siblings = this.map(function(index, element) {
          return [].slice.call(core_toArray(element.parentNode.children)).filter(function(child) {
            return child !== element;
          });
        });
        return _filtered(siblings, selector);
      },
      children: function(selector) {
        return _filtered(this.map(function() {
          return [].slice.call(core_toArray(this.children));
        }), selector);
      },
      first: function() {
        return $(this[0]);
      },
      last: function() {
        return $(this[this.length - 1]);
      },
      next: function() {
        return $(_getSibling.call(this, "nextSibling"));
      },
      prev: function() {
        return $(_getSibling.call(this, "previousSibling"));
      },
      closest: function(selector, context) {
        var candidates, node;
        node = this[0];
        candidates = $(selector);
        if (!candidates.length) {
          node = null;
        }
        while (node && candidates.indexOf(node) < 0) {
          node = node !== context && node !== document && node.parentNode;
        }
        return $(node);
      }
    };
  })($);

  Events = (function($) {
    var Events_desktop, Events_fixHooks, Events_handlers, Events_id, Events_keyHooks, Events_methods, Events_mouseHooks, Events_props, _createProxy, _createProxyCallback, _environmentEvent, _findHandlers, _getElementId, _returnFalse, _returnTrue, _subscribe, _unsubscribe;
    $.Event = function(src, props) {
      if (!(this instanceof $.Event)) {
        return new $.Event(src, props);
      }
      if (src && src.type) {
        this.originalEvent = src;
        this.type = src.type;
        this.isDefaultPrevented = ((src.defaultPrevented || src.returnValue === false || src.getPreventDefault && src.getPreventDefault()) ? _returnTrue : _returnFalse);
      } else {
        this.type = src;
      }
      if (props) {
        $.extend(this, props);
      }
      this.timeStamp = src && src.timeStamp || $.now();
      return this[$.expando] = true;
    };
    $.now = function() {
      return (new Date()).getTime();
    };
    $.event = {
      fix: function(event) {
        var copy, fixHook, i, originalEvent, prop, type;
        if (event[$.expando]) {
          return event;
        }
        type = event.type;
        originalEvent = event;
        fixHook = Events_fixHooks[type];
        if (!fixHook) {
          Events_fixHooks[type] = fixHook = (/^(?:mouse|contextmenu)|click/.test(type) ? Events_mouseHooks : (/^key/.test(type) ? Events_keyHooks : {}));
        }
        copy = fixHook.props ? Events_props.concat(fixHook.props) : Events_props;
        event = new $.Event(originalEvent);
        i = copy.length;
        while (i--) {
          prop = copy[i];
          event[prop] = originalEvent[prop];
        }
        if (!event.target) {
          event.target = originalEvent.srcElement || document;
        }
        if (event.target.nodeType === 3) {
          event.target = event.target.parentNode;
        }
        event.metaKey = !!event.metaKey;
        if (fixHook.filter) {
          return fixHook.filter(event, originalEvent);
        } else {
          return event;
        }
      },
      add: function(element, event_name, callback) {
        if (element.addEventListener != null) {
          return element.addEventListener(event_name, callback, false);
        } else if (element.attachEvent != null) {
          return element.attachEvent("on" + event_name, callback);
        } else {
          return element["on" + event_name] = callback;
        }
      },
      remove: function(element, event_name, callback) {
        if (element.removeEventListener) {
          return element.removeEventListener(event_name, callback, false);
        } else if (element.detachEvent) {
          return element.detachEvent("on" + event_name, callback);
        } else {
          return element["on" + event_name] = null;
        }
      }
    };
    Events_handlers = {};
    Events_id = 1;
    Events_methods = {
      preventDefault: "isDefaultPrevented",
      stopImmediatePropagation: "isImmediatePropagationStopped",
      stopPropagation: "isPropagationStopped"
    };
    Events_desktop = {
      touchstart: "mousedown",
      touchmove: "mousemove",
      touchend: "mouseup",
      touch: "click",
      doubletap: "dblclick",
      orientationchange: "resize"
    };
    Events_props = "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" ");
    Events_fixHooks = {};
    Events_keyHooks = {
      props: "char charCode key keyCode".split(' '),
      filter: function(event, original) {
        if (event.which == null) {
          event.which = (original.charCode != null ? original.charCode : original.keyCode);
        }
        return event;
      }
    };
    Events_mouseHooks = {
      props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(event, original) {
        var body, button, doc, eventDoc, fromElement;
        button = original.button;
        fromElement = original.fromElement;
        if ((event.pageX == null) && (original.clientX != null)) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.relatedTarget && fromElement) {
          event.relatedTarget = (fromElement === event.target ? original.toElement : fromElement);
        }
        if (!event.which && button !== undefined) {
          event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
        }
        return event;
      }
    };
    _subscribe = function(element, event, callback, selector, delegate_callback) {
      var delegate, element_handlers, element_id, handler;
      event = _environmentEvent(event);
      element_id = _getElementId(element);
      element_handlers = Events_handlers[element_id] || (Events_handlers[element_id] = []);
      delegate = delegate_callback && delegate_callback(callback, event);
      handler = {
        event: event,
        callback: callback,
        selector: selector,
        proxy: _createProxyCallback(delegate, callback, element),
        delegate: delegate,
        index: element_handlers.length
      };
      element_handlers.push(handler);
      return $.event.add(element, handler.event, handler.proxy);
    };
    _unsubscribe = function(element, event, callback, selector) {
      var element_id, handler, len1, m, ref, results;
      event = _environmentEvent(event);
      element_id = _getElementId(element);
      ref = _findHandlers(element_id, event, callback, selector);
      results = [];
      for (m = 0, len1 = ref.length; m < len1; m++) {
        handler = ref[m];
        delete Events_handlers[element_id][handler.index];
        results.push($.event.remove(element, handler.event, handler.proxy));
      }
      return results;
    };
    _getElementId = function(element) {
      return element._id || (element._id = Events_id++);
    };
    _environmentEvent = function(event) {
      var environment_event;
      environment_event = (($.Environment.isMobile()) ? event : Events_desktop[event]);
      return environment_event || event;
    };
    _createProxyCallback = function(delegate, callback, element) {
      var proxy;
      callback = delegate || callback;
      proxy = function(event) {
        var result;
        event = $.event.fix(event);
        result = callback.apply(element, [event].concat(event.data));
        if (result === false) {
          event.preventDefault();
        }
        return result;
      };
      return proxy;
    };
    _findHandlers = function(element_id, event, fn, selector) {
      return (Events_handlers[element_id] || []).filter(function(handler) {
        return handler && (!event || handler.event === event) && (!fn || handler.callback === fn) && (!selector || handler.selector === selector);
      });
    };
    _createProxy = function(event) {
      var proxy;
      proxy = $.extend({
        originalEvent: event
      }, event);
      $.each(Events_methods, function(name, method) {
        proxy[name] = function() {
          this[method] = function() {
            return true;
          };
          return event[name].apply(event, arguments);
        };
        return proxy[method] = function() {
          return false;
        };
      });
      return proxy;
    };
    _returnTrue = function() {
      return true;
    };
    _returnFalse = function() {
      return false;
    };
    return {
      ready: function(callback) {
        var flush, fn, fns, hack, loaded, wait;
        fns = [];
        hack = document.documentElement.doScroll;
        loaded = (hack ? /^loaded|^c/ : /^loaded|c/).test(document['readyState']);
        flush = function(f) {
          var results;
          loaded = 1;
          results = [];
          while (f = fns.shift()) {
            results.push(f());
          }
          return results;
        };
        if (typeof document.addEventListener === "function") {
          document.addEventListener('DOMContentLoaded', fn = function() {
            document.removeEventListener('DOMContentLoaded', fn, false);
            return flush();
          }, false);
        }
        if (hack) {
          document.attachEvent('onreadystatechange', fn = function() {
            if (/^c/.test(document['readyState'])) {
              document.detachEvent('onreadystatechange', fn);
              return flush();
            }
          });
        }
        if (hack) {
          if (window.top !== window.self) {
            if (loaded) {
              callback();
            } else {
              fns.push(callback);
            }
          } else {
            (wait = function() {
              try {
                document.documentElement.doScroll('left');
              } catch (error1) {
                return setTimeout((function() {
                  return wait();
                }), 50);
              }
              return callback();
            })();
          }
        } else {
          if (loaded) {
            callback();
          } else {
            fns.push(callback);
          }
        }
        return this;
      },
      on: function(event, selector, callback) {
        if ((selector == null) || typeof selector === "function") {
          return this.bind(event, selector);
        } else {
          return this.delegate(selector, event, callback);
        }
      },
      off: function(event, selector, callback) {
        if ((selector == null) || typeof selector === "function") {
          return this.unbind(event, selector);
        } else {
          return this.undelegate(selector, event, callback);
        }
      },
      bind: function(event, callback) {
        return this.each(function() {
          _subscribe(this, event, callback);
        });
      },
      unbind: function(event, callback) {
        return this.each(function() {
          _unsubscribe(this, event, callback);
        });
      },
      delegate: function(selector, event, callback) {
        return this.each(function(i, element) {
          _subscribe(element, event, callback, selector, function(fn) {
            return function(e) {
              var evt, match;
              if (match = $(e.target || e.srcElement || document).closest(selector, element).get(0)) {
                evt = $.extend(_createProxy(e), {
                  currentTarget: match,
                  liveFired: element
                });
                return fn.apply(match, [evt].concat([].slice.call(arguments, 1)));
              }
            };
          });
        });
      },
      undelegate: function(selector, event, callback) {
        return this.each(function() {
          _unsubscribe(this, event, callback, selector);
        });
      },
      triggerHandler: function(event, args) {
        var result;
        result = null;
        this.each(function(i, element) {
          var e, element_id, ref;
          e = _createProxy($.type(event) === 'string' ? $.Event(event) : event);
          e._args = args;
          e.target = element;
          element_id = _getElementId(element);
          return $.each(_findHandlers(element_id, (ref = event.type) != null ? ref : event), function(i, handler) {
            result = handler.proxy(e);
            if (typeof e.isImmediatePropagationStopped === "function" ? e.isImmediatePropagationStopped() : void 0) {
              return false;
            }
          });
        });
        return result;
      }
    };
  })($);

  Style = (function($) {
    var _computedStyle, _existsClass;
    _existsClass = function(name, className) {
      var classes;
      classes = className.split(/\s+/g);
      return classes.indexOf(name) >= 0;
    };
    _computedStyle = function(element, property) {
      return window.getComputedStyle(element, "").getPropertyValue(property);
    };
    return {
      addClass: function(name) {
        return this.each(function() {
          if (!_existsClass(name, this.className)) {
            this.className += " " + name;
            return this.className = this.className.trim();
          }
        });
      },
      removeClass: function(name) {
        return this.each(function() {
          if (!name) {
            return this.className = "";
          } else {
            if (_existsClass(name, this.className)) {
              return this.className = this.className.replace(name, " ").replace(/\s+/g, " ").trim();
            }
          }
        });
      },
      toggleClass: function(name) {
        return this.each(function() {
          if (_existsClass(name, this.className)) {
            return this.className = this.className.replace(name, " ");
          } else {
            this.className += " " + name;
            return this.className = this.className.trim();
          }
        });
      },
      hasClass: function(name) {
        return this.length > 0 && _existsClass(name, this[0].className);
      },
      css: function(property, value) {
        if (typeof value !== "undefined") {
          return this.each(function() {
            return this.style[property] = value;
          });
        } else if (this.length > 0) {
          return this[0].style[property] || _computedStyle(this[0], property);
        }
      }
    };
  })($);

  Dom = (function($) {
    var _stripScripts;
    _stripScripts = function(text, callback) {
      var code, html, item, len1, m, script, scripts, src;
      scripts = [];
      html = text.replace(/<script([\s\S]*?)>([\s\S]*?)<\/script>/gi, function(all, attr, code) {
        scripts.push({
          attr: attr,
          code: code
        });
        return '';
      });
      callback.call(this, html);
      if (scripts.length > 0) {
        for (m = 0, len1 = scripts.length; m < len1; m++) {
          item = scripts[m];
          src = item.attr.match(/src.*?=.*?[\"'](.+?)[\"']/i);
          if (src != null) {
            src = src[1];
          }
          code = item.code;
          if ((src !== null && src !== '') || code !== '') {
            script = document.createElement('script');
            if (src !== null) {
              script.setAttribute('src', src);
            }
            script.setAttribute('type', 'text/javascript');
            if (code !== "") {
              script.text = code;
            }
            this.appendChild(script);
          }
        }
      }
    };
    return {
      text: function(value) {
        var i, m, ref, ret;
        if (value == null) {
          ret = [];
          for (i = m = 0, ref = this.length; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
            ret.push(this[i][(this[i].textContent != null ? 'textContent' : 'innerText')]);
          }
          return ret.join('');
        } else {
          return this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
        }
      },
      html: function(value) {
        var type;
        type = $.type(value);
        if (type === "undefined") {
          if (this.length > 0) {
            return this[0].innerHTML;
          } else {

          }
        } else {
          return this.each(function() {
            var len1, m, results, v;
            if (type === "string") {
              return _stripScripts.call(this, value, function(html) {
                return this.innerHTML = html;
              });
            } else if (type === "array") {
              results = [];
              for (m = 0, len1 = value.length; m < len1; m++) {
                v = value[m];
                results.push($(this).html(v));
              }
              return results;
            } else {
              return this.innerHTML = this.innerHTML + $(value).html();
            }
          });
        }
      },
      append: function(value) {
        var type;
        type = $.type(value);
        return this.each(function() {
          var len1, m, results, v;
          if (type === "string") {
            return _stripScripts.call(this, value, function(html) {
              return this.insertAdjacentHTML("beforeend", html);
            });
          } else if (type === "array" || ((value != null ? value.length : void 0) != null) && core_isArraylike(value)) {
            results = [];
            for (m = 0, len1 = value.length; m < len1; m++) {
              v = value[m];
              results.push($(this).append(v));
            }
            return results;
          } else {
            return this.appendChild(value);
          }
        });
      },
      prepend: function(value) {
        var type;
        type = $.type(value);
        return this.each(function() {
          var len1, m, results, v;
          if (type === "string") {
            return _stripScripts.call(this, value, function(html) {
              return this.insertAdjacentHTML("afterbegin", html);
            });
          } else if (type === "array") {
            results = [];
            for (m = 0, len1 = value.length; m < len1; m++) {
              v = value[m];
              results.push($(this).prepend(v));
            }
            return results;
          } else {
            return this.insertBefore(value, this.firstChild);
          }
        });
      },
      replaceWith: function(value) {
        var type;
        type = $.type(value);
        this.each(function() {
          var len1, m, results, v;
          if (this.parentNode) {
            if (type === "string") {
              return _stripScripts.call(this, value, function(html) {
                return this.insertAdjacentHTML("beforeBegin", html);
              });
            } else if (type === "array") {
              results = [];
              for (m = 0, len1 = value.length; m < len1; m++) {
                v = value[m];
                results.push($(this).replaceWith(v));
              }
              return results;
            } else {
              return this.parentNode.insertBefore(value, this);
            }
          }
        });
        return this.remove();
      },
      after: function(value) {
        var type;
        type = $.type(value);
        return this.each(function() {
          var len1, m, results, v;
          if (this.parentNode) {
            if (type === "string") {
              return _stripScripts.call(this, value, function(html) {
                return this.insertAdjacentHTML("afterend", html);
              });
            } else if (type === "array") {
              results = [];
              for (m = 0, len1 = value.length; m < len1; m++) {
                v = value[m];
                results.push($(this).after(v));
              }
              return results;
            } else {
              return this.parentNode.insertBefore(value, $(this).next());
            }
          }
        });
      },
      empty: function() {
        return this.each(function() {
          return this.innerHTML = "";
        });
      },
      attr: function(name, value) {
        if (this.length === 0) {
          null;
        }
        if ($.type(name) === "string" && value === void 0) {
          return this[0].getAttribute(name);
        } else {
          return this.each(function() {
            return this.setAttribute(name, value);
          });
        }
      },
      removeAttr: function(name) {
        return this.each(function() {
          return this.removeAttribute(name);
        });
      },
      data: function(name, value) {
        return this.attr("data-" + name, value);
      },
      removeData: function(name) {
        return this.removeAttr("data-" + name);
      },
      val: function(value) {
        if ($.type(value) === "string") {
          return this.each(function() {
            return this.value = value;
          });
        } else {
          if (this.length > 0) {
            return this[0].value;
          } else {
            return null;
          }
        }
      },
      show: function() {
        return this.css("display", "");
      },
      hide: function() {
        return this.css("display", "none");
      },
      height: function() {
        var offset;
        offset = this.offset();
        return offset.height;
      },
      width: function() {
        var offset;
        offset = this.offset();
        return offset.width;
      },
      offset: function() {
        var bounding, ref, ref1;
        if (this.length === 0) {
          return {};
        }
        bounding = this[0].getBoundingClientRect();
        return {
          left: bounding.left + ((ref = window.pageXOffset) != null ? ref : document.documentElement.scrollLeft),
          top: bounding.top + ((ref1 = window.pageYOffset) != null ? ref1 : document.documentElement.scrollTop),
          width: bounding.right - bounding.left,
          height: bounding.bottom - bounding.top
        };
      },
      remove: function() {
        return this.each(function() {
          if (this.parentNode != null) {
            return this.parentNode.removeChild(this);
          }
        });
      }
    };
  })($);

  core = {
    length: 0,
    init: function(a) {
      var len;
      return core_array.push.apply(this, a && a.nodeType ? [a] : ("" + a === a ? a[0] === "<" && a[a.length - 1] === ">" && a.length >= 3 ? (len = a.length - 1 - ((a[a.length - 2] === '/') ? 1 : 0), [document.createElement(a.slice(1, len))]) : core_toArray(document.querySelectorAll(a)) : ((function() {
        if (/^f/.test(typeof a)) {
          return [$(document).ready(a)];
        } else {
          switch ($.type(a)) {
            case 'array':
              return a;
            case 'object':
              return [a];
            default:
              return [];
          }
        }
      })())));
    },
    toArray: function() {
      return [].slice.call(this);
    },
    get: function(num) {
      if (num === null) {
        return this.toArray();
      } else if (num < 0) {
        return this[this.length + num];
      } else {
        return this[num];
      }
    },
    each: function(callback, args) {
      return $.each(this, callback, args);
    },
    splice: core_array.splice,
    map: function(fn) {
      return $.map(this, function(el, i) {
        return fn.call(el, i, el);
      });
    },
    'indexOf': core_array.indexOf
  };

  ref = [Query, Events, Style, Dom];
  for (m = 0, len1 = ref.length; m < len1; m++) {
    o = ref[m];
    for (k in o) {
      v = o[k];
      core[k] = v;
    }
  }

  $.prototype = $.fn = core.init.prototype = core;

  $.support = {};

  if (document.querySelectorAll == null) {
    document.querySelectorAll = (function() {
      var style;
      style = document.createStyleSheet();
      return function(selectors) {
        var all, elements, i, j, p, q, ref1, ref2;
        all = document.all;
        elements = [];
        selectors = selectors.replace(/\[for\b/gi, '[htmlFor').split(',');
        for (i = p = 0, ref1 = selectors.length; p < ref1; i = p += 1) {
          style.addRule(selectors[i], 'k:v', 0);
          for (j = q = 0, ref2 = all.length; q < ref2; j = q += 1) {
            all[j].currentStyle.k && elements.push(all[j]);
          }
          style.removeRule(0);
        }
        return elements;
      };
    })();
  }

  if (document.querySelector == null) {
    document.querySelector = function(selectors) {
      var elements;
      elements = document.querySelectorAll(selectors);
      if (elements.length) {
        return elements[0];
      } else {
        return null;
      }
    };
  }

  if (document.getElementsByClassName == null) {
    document.getElementsByClassName = function(classNames) {
      classNames = String(classNames).replace(/^|\s+/g, '.');
      return document.querySelectorAll(classNames);
    };
  }

  if ((base = Array.prototype).filter == null) {
    base.filter = function(fn) {
      var i, len, res, t, thisp, val;
      if (this == null) {
        throw new TypeError();
      }
      if (typeof fn !== "function") {
        throw new TypeError();
      }
      t = Object(this);
      len = t.length >>> 0;
      res = [];
      thisp = arguments[1];
      i = 0;
      while (i < len) {
        if (i in t) {
          val = t[i];
          if (fn.call(thisp, val, i, t)) {
            res.push(val);
          }
        }
        i++;
      }
      return res;
    };
  }

  if ((base1 = String.prototype).trim == null) {
    base1.trim = function() {
      return this.replace(/^\s+|\s+$/g, '');
    };
  }

  if (window.JSON == null) {
    window.JSON = (function() {
      var cx, escapable, f, gap, indent, meta, quote, rep, str;
      cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      gap = void 0;
      indent = void 0;
      meta = {
        "\b": "\\b",
        "\t": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        "\"": "\\\"",
        "\\": "\\\\"
      };
      rep = void 0;
      f = function(n) {
        if (n < 10) {
          return "0" + n;
        } else {
          return n;
        }
      };
      quote = function(string) {
        escapable.lastIndex = 0;
        if (escapable.test(string)) {
          return "\"" + string.replace(escapable, function(a) {
            var c;
            c = meta[a];
            if (typeof c === "string") {
              return c;
            } else {
              return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            }
          }) + "\"";
        } else {
          return "\"" + string + "\"";
        }
      };
      str = function(key, holder) {
        var i, length, mind, partial, value;
        mind = gap;
        value = holder[key];
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            return quote(value);
          case "number":
            if (isFinite(value)) {
              return String(value);
            } else {
              return "null";
            }
          case "boolean":
          case "null":
            return String(value);
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              i = 0;
              while (i < length) {
                partial[i] = str(i, value) || "null";
                i += 1;
              }
              v = (partial.length === 0 ? "[]" : (gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]"));
              gap = mind;
              return v;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              i = 0;
              while (i < length) {
                if (typeof rep[i] === "string") {
                  k = rep[i];
                  v = str(k, value);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
                i += 1;
              }
            } else {
              for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                  v = str(k, value);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
              }
            }
            v = (partial.length === 0 ? "{}" : (gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}"));
            gap = mind;
            return v;
        }
      };
      if (typeof Date.prototype.toJSON !== "function") {
        Date.prototype.toJSON = function() {
          if (isFinite(this.valueOf())) {
            return this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z";
          } else {
            return null;
          }
        };
        String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function() {
          return this.valueOf();
        };
      }
      return {
        stringify: function(value, replacer, space) {
          var i;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            i = 0;
            while (i < space) {
              indent += {
                " ": i += 1
              };
            }
          } else {
            if (typeof space === "string") {
              indent = space;
            }
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", {
            "": value
          });
        },
        parse: function(text, reviver) {
          var j, walk;
          walk = function(holder, key) {
            var value;
            value = holder[key];
            if (value && typeof value === "object") {
              for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                  v = walk(value, k);
                  if (v !== undefined) {
                    value[k] = v;
                  } else {
                    delete value[k];
                  }
                }
              }
            }
            return reviver.call(holder, key, value);
          };
          j = void 0;
          text = String(text);
          cx.lastIndex = 0;
          if (cx.test(text)) {
            text = text.replace(cx, function(a) {
              return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            });
          }
          if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) {
            j = eval("(" + text + ")");
            return (typeof reviver === "function" ? walk({
              "": j
            }, "") : j);
          }
          throw new SyntaxError("JSON.parse");
        }
      };
    })();
  }

  if (window.getComputedStyle == null) {
    window.getComputedStyle = (function() {
      var CSSStyleDeclaration, getComputedStylePixel, setShortStyleProperty;
      getComputedStylePixel = function(element, property, fontSize) {
        var rootSize, size, suffix, value;
        value = element.currentStyle[property].match(/([\d\.]+)(%|cm|em|in|mm|pc|pt|)/) || [0, 0, ""];
        size = value[1];
        suffix = value[2];
        fontSize = (!fontSize ? fontSize : (/%|em/.test(suffix) && element.parentElement ? getComputedStylePixel(element.parentElement, "fontSize", null) : 16));
        rootSize = (property === "fontSize" ? fontSize : (/width/i.test(property) ? element.clientWidth : element.clientHeight));
        if (suffix === "%") {
          return size / 100 * rootSize;
        } else {
          if (suffix === "cm") {
            return size * 0.3937 * 96;
          } else {
            if (suffix === "em") {
              return size * fontSize;
            } else {
              if (suffix === "in") {
                return size * 96;
              } else {
                if (suffix === "mm") {
                  return size * 0.3937 * 96 / 10;
                } else {
                  if (suffix === "pc") {
                    return size * 12 * 96 / 72;
                  } else {
                    if (suffix === "pt") {
                      return size * 96 / 72;
                    } else {
                      return size;
                    }
                  }
                }
              }
            }
          }
        }
      };
      setShortStyleProperty = function(style, property) {
        var b, borderSuffix, l, r, t;
        borderSuffix = (property === "border" ? "Width" : "");
        t = property + "Top" + borderSuffix;
        r = property + "Right" + borderSuffix;
        b = property + "Bottom" + borderSuffix;
        l = property + "Left" + borderSuffix;
        return style[property] = (style[t] === style[r] && style[t] === style[b] && style[t] === style[l] ? [style[t]] : (style[t] === style[b] && style[l] === style[r] ? [style[t], style[r]] : (style[l] === style[r] ? [style[t], style[r], style[b]] : [style[t], style[r], style[b], style[l]]))).join(" ");
      };
      CSSStyleDeclaration = function(element) {
        var currentStyle, fontSize, property, style, unCamelCase;
        style = this;
        currentStyle = element.currentStyle;
        fontSize = getComputedStylePixel(element, "fontSize");
        unCamelCase = function(match) {
          return "-" + match.toLowerCase();
        };
        for (property in currentStyle) {
          Array.prototype.push.call(style, (property === "styleFloat" ? "float" : property.replace(/[A-Z]/, unCamelCase)));
          if (property === "width") {
            style[property] = element.offsetWidth + "px";
          } else if (property === "height") {
            style[property] = element.offsetHeight + "px";
          } else if (property === "styleFloat") {
            style.float = currentStyle[property];
          } else if (/margin.|padding.|border.+W/.test(property) && style[property] !== "auto") {
            style[property] = Math.round(getComputedStylePixel(element, property, fontSize)) + "px";
          } else {
            style[property] = currentStyle[property];
          }
        }
        setShortStyleProperty(style, "margin");
        setShortStyleProperty(style, "padding");
        setShortStyleProperty(style, "border");
        return style.fontSize = Math.round(fontSize) + "px";
      };
      CSSStyleDeclaration.prototype = {
        constructor: CSSStyleDeclaration,
        getPropertyPriority: function() {
          throw new Error("NotSupportedError: DOM Exception 9");
        },
        getPropertyValue: function(property) {
          return this[property.replace(/-\w/g, function(match) {
            return match[1].toUpperCase();
          })];
        },
        item: function(index) {
          return this[index];
        },
        removeProperty: function() {
          throw new Error("NoModificationAllowedError: DOM Exception 7");
        },
        setProperty: function() {
          throw new Error("NoModificationAllowedError: DOM Exception 7");
        },
        getPropertyCSSValue: function() {
          throw new Error("NotSupportedError: DOM Exception 9");
        }
      };
      return function(element) {
        return new CSSStyleDeclaration(element);
      };
    })();
  }

  for (i in $($.support)) {
    break;
  }

  $.support.ownLast = i !== "0";

  if ((base2 = Array.prototype).indexOf == null) {
    base2.indexOf = function(elem) {
      var p, q, ref1, ref2;
      if (this.charAt != null) {
        for (i = p = 0, ref1 = this.length; p < ref1; i = p += 1) {
          if (this.charAt(i) === elem) {
            return i;
          }
        }
      } else {
        for (i = q = 0, ref2 = this.length; q < ref2; i = q += 1) {
          if (this[i] === elem) {
            return i;
          }
        }
      }
      return -1;
    };
  }

}).call(this);
